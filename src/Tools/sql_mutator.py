#!/usr/bin/env python3
"""
Lightweight SQL dialect-aware mutator using sqlglot.

Features (safe, conservative):
- Parse & re-generate with target dialect via sqlglot
- Mutations:
  1) LIMIT/OFFSET boundary tweaks (±1, 0, big numbers)
  2) Integer literal perturbation (±1, sign flip, clamp to 32/64-bit edges)
  3) Optional SELECT DISTINCT toggle (when applicable)

CLI
  python src/Tools/sql_mutator.py \
    --dialect mysql \
    --variants 5 \
    --input-sql "SELECT a, COUNT(*) FROM t WHERE x > 9223372036854775807 ORDER BY a LIMIT 10;" \
    --enable-distinct-toggle \
    --format jsonl

Outputs JSONL by default: {"id": int, "sql": "..."}

Notes
- We prioritize syntax validity: every variant is reparsed & regenerated by sqlglot
- Mutations are minimal (1-3 edits per variant) to keep them near the seed
"""

from __future__ import annotations

import argparse
import json
import random
import re
import sys
from dataclasses import dataclass
from typing import Iterable, List, Optional, Tuple

import sqlglot
from sqlglot import exp


# 32/64-bit integer edges commonly useful for DB fuzzing
INT32_MAX = 2**31 - 1
INT32_MIN = -(2**31)
INT64_MAX = 2**63 - 1
INT64_MIN = -(2**63)

BOUNDARY_SET = [
    0, 1, 2, 10, 100,
    -1, -2, -10,
    INT32_MAX, INT32_MAX - 1, INT32_MIN, INT32_MIN + 1,
    INT64_MAX, INT64_MAX - 1, INT64_MIN, INT64_MIN + 1,
]


@dataclass
class MutatorConfig:
    dialect: str = "mysql"
    variants: int = 5
    enable_distinct_toggle: bool = False
    seed: Optional[int] = None
    # Avoid low-value invalids: don't let generic int-mutation touch LIMIT/OFFSET literals
    protect_limit_offset: bool = True
    # When mutating LIMIT/OFFSET specifically, clamp to non-negative
    clamp_limit_offset_nonnegative: bool = True


def _parse_statements(sql_text: str, dialect: str) -> List[exp.Expression]:
    # Parse into a list of statements; raises if not parseable
    return list(sqlglot.parse(sql_text, read=dialect))


def _render_sql(expr: exp.Expression, dialect: str) -> str:
    # Re-generate SQL with target dialect
    return expr.sql(dialect=dialect)


def _is_within_limit(node: exp.Expression) -> bool:
    """Check if a node is within a LIMIT expression or its OFFSET."""
    p = node.parent
    while p is not None:
        if isinstance(p, exp.Limit):
            return True
        p = p.parent
    return False


def _iter_integer_literals(expr: exp.Expression, cfg: MutatorConfig) -> Iterable[exp.Literal]:
    for node in expr.walk():
        if isinstance(node, exp.Literal) and node.is_number:
            # sqlglot's Literal may contain floats; we only mutate integers
            try:
                int(str(node.this))
            except Exception:
                continue
            if cfg.protect_limit_offset and _is_within_limit(node):
                continue
            yield node


def _choose_boundary_near(value: int) -> int:
    # Prefer a small delta around the value, occasionally jump to big edges
    r = random.random()
    if r < 0.5:
        return value + random.choice([-2, -1, 0, 1, 2])
    elif r < 0.75:
        return -value
    else:
        return random.choice(BOUNDARY_SET)


def _mutate_integer_literals(expr: exp.Expression, cfg: MutatorConfig, max_mutations: int = 2) -> bool:
    changed = False
    literals = list(_iter_integer_literals(expr, cfg))
    if not literals:
        return False
    random.shuffle(literals)
    for lit in literals[:max_mutations]:
        try:
            old_v = int(str(lit.this))
        except Exception:
            continue
        new_v = _choose_boundary_near(old_v)
        if new_v != old_v:
            lit.replace(exp.Literal.number(new_v))
            changed = True
    return changed


def _find_first_select(expr: exp.Expression) -> Optional[exp.Select]:
    if isinstance(expr, exp.Select):
        return expr
    for node in expr.walk():
        if isinstance(node, exp.Select):
            return node
    return None


def _mutate_limit_offset(expr: exp.Expression, cfg: MutatorConfig) -> bool:
    """Tweak LIMIT/OFFSET if present, else optionally add a LIMIT to top-level SELECT."""
    changed = False

    # Try to find LIMIT node
    limit_node: Optional[exp.Limit] = None
    for node in expr.walk():
        if isinstance(node, exp.Limit):
            limit_node = node
            break

    def _pick_limit_near(old: Optional[int]) -> int:
        if old is None:
            return random.choice([0, 1, 2, 10, 100, INT32_MAX, INT64_MAX])
        val = _choose_boundary_near(old)
        if cfg.clamp_limit_offset_nonnegative:
            val = max(0, val)
        return val

    if limit_node is not None:
        # Tweak existing LIMIT / OFFSET
        # limit_node.expression is the LIMIT value; limit_node.args.get("offset") is OFFSET
        # Be resilient to missing attributes
        try:
            old_limit = int(limit_node.expression.this) if isinstance(limit_node.expression, exp.Literal) else None
        except Exception:
            old_limit = None
        try:
            offset = limit_node.args.get("offset")
            old_offset = int(offset.this) if isinstance(offset, exp.Literal) else None
        except Exception:
            old_offset = None

        new_limit = _pick_limit_near(old_limit)
        if old_limit is None or new_limit != old_limit:
            limit_node.set("expression", exp.Literal.number(new_limit))
            changed = True

        if random.random() < 0.5:
            new_offset = _pick_limit_near(old_offset or 0)
            limit_node.set("offset", exp.Literal.number(new_offset))
            changed = True
        else:
            # Occasionally remove OFFSET
            if limit_node.args.get("offset") is not None and random.random() < 0.3:
                limit_node.set("offset", None)
                changed = True
    else:
        # Optionally add a LIMIT to a SELECT
        sel = _find_first_select(expr)
        if sel is not None and random.random() < 0.8:
            lim_value = random.choice([0, 1, 2, 10, INT32_MAX, INT64_MAX])
            new_limit = exp.Limit(this=sel, expression=exp.Literal.number(lim_value))
            # Replace the select with limited select by wrapping if needed
            # In many cases, LIMIT is attached at the query level; we try to set on parent
            sel.replace(new_limit)
            changed = True

    return changed


def _toggle_distinct(expr: exp.Expression) -> bool:
    sel = _find_first_select(expr)
    if not sel:
        return False
    # sqlglot Select has arg "distinct" which is either None or exp.Distinct
    has_distinct = sel.args.get("distinct") is not None
    if has_distinct:
        sel.set("distinct", None)
    else:
        sel.set("distinct", exp.Distinct())
    return True


def mutate_once(expr: exp.Expression, cfg: MutatorConfig) -> Optional[exp.Expression]:
    """Apply 1-3 safe mutations and re-validate by re-parsing.
    Returns a NEW expression on success, or None on failure.
    """
    mutated = expr.copy()

    ops = [
        lambda e: _mutate_integer_literals(e, cfg),
        lambda e: _mutate_limit_offset(e, cfg),
    ]
    if cfg.enable_distinct_toggle:
        ops.append(_toggle_distinct)

    # Pick 1-3 distinct operations randomly
    k = random.choice([1, 2, 3])
    random.shuffle(ops)
    chosen = ops[:k]

    changed_any = False
    for op in chosen:
        try:
            changed_any = op(mutated) or changed_any
        except Exception:
            # Ignore individual op errors, try others
            continue

    if not changed_any:
        return None

    # Validate by generating SQL and re-parsing
    try:
        sql_text = _render_sql(mutated, cfg.dialect)
        # Ensure it parses back
        _ = _parse_statements(sql_text, cfg.dialect)
    except Exception:
        return None
    return mutated


def generate_variants(sql_text: str, cfg: MutatorConfig) -> List[str]:
    # Parse all statements, then for each create variants nearby and concatenate
    try:
        stmts = _parse_statements(sql_text, cfg.dialect)
    except Exception as e:
        raise SystemExit(f"Parse error for seed SQL with dialect='{cfg.dialect}': {e}")

    out: List[str] = []
    attempts = 0
    target = cfg.variants
    max_attempts = max(50, target * 10)

    # Create variants across the whole script by mutating the last statement (most common case)
    # and occasionally earlier ones.
    while len(out) < target and attempts < max_attempts:
        attempts += 1
        base = random.choice(stmts)
        mutated = mutate_once(base, cfg)
        if not mutated:
            continue
        try:
            out_sql = _render_sql(mutated, cfg.dialect)
        except Exception:
            continue
        # Deduplicate simple duplicates
        if out_sql not in out:
            out.append(out_sql)

    return out


def _read_input_sql(args: argparse.Namespace) -> str:
    if args.input_sql:
        return args.input_sql
    if args.input_file:
        with open(args.input_file, "r", encoding="utf-8") as f:
            return f.read()
    data = sys.stdin.read()
    if not data.strip():
        raise SystemExit("No input SQL provided. Use --input-sql, --input-file, or pipe via stdin.")
    return data


def main(argv: Optional[List[str]] = None) -> int:
    p = argparse.ArgumentParser(description="SQL dialect-aware mutator using sqlglot")
    p.add_argument("--dialect", default="mysql", help="Target SQL dialect (mysql, postgres, sqlite, etc.)")
    p.add_argument("--variants", type=int, default=5, help="Number of variants to generate")
    p.add_argument("--seed", type=int, default=None, help="Random seed")
    p.add_argument("--input-sql", default=None, help="Inline seed SQL string")
    p.add_argument("--input-file", default=None, help="Path to file containing seed SQL")
    p.add_argument("--format", choices=["jsonl", "sql"], default="jsonl", help="Output format")
    p.add_argument("--enable-distinct-toggle", action="store_true", help="Allow toggling SELECT DISTINCT")

    args = p.parse_args(argv)

    if args.seed is not None:
        random.seed(args.seed)

    cfg = MutatorConfig(
        dialect=args.dialect,
        variants=args.variants,
        enable_distinct_toggle=args.enable_distinct_toggle,
        seed=args.seed,
    )

    seed_sql = _read_input_sql(args)
    variants = generate_variants(seed_sql, cfg)

    if args.format == "jsonl":
        for i, sql_text in enumerate(variants):
            obj = {"id": i, "sql": sql_text}
            sys.stdout.write(json.dumps(obj, ensure_ascii=False) + "\n")
    else:
        # Plain SQL separated by semicolons
        for sql_text in variants:
            sys.stdout.write(sql_text.rstrip("; ") + ";\n")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

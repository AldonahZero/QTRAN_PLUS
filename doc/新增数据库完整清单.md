# 新增数据库完整清单

本文档说明在 QTRAN 框架中新增一个数据库时需要修改的所有位置。以 SurrealDB 为例。

---

## 📋 清单概览

- [ ] **1. Docker 容器配置**
- [ ] **2. 数据库连接参数配置**
- [ ] **3. 数据库连接器代码**
- [ ] **4. 知识库创建**
- [ ] **5. 知识库导入器集成**
- [ ] **6. 翻译流程集成**
- [ ] **7. 预处理脚本（可选）**
- [ ] **8. 测试验证**

---

## 1. Docker 容器配置 ✅

### 文件：`docker-compose.yml`

**目的**：将新数据库添加到 Docker Compose 集群中

**位置**：
```yaml
services:
  # ... 其他服务 ...
  
  surrealdb:  # 新增的数据库服务
    image: surrealdb/surrealdb:latest
    container_name: surrealdb_QTRAN
    command: start --log trace --user root --pass root memory
    ports:
      - "8000:8000"
    volumes:
      - surrealdb_data:/data
    networks:
      - db_network

volumes:
  # ... 其他卷 ...
  surrealdb_data:  # 新增数据卷
```

**关键点**：
- `container_name` 必须以 `_QTRAN` 结尾
- 必须在 `db_network` 网络中
- 端口映射要避免冲突
- 添加持久化卷（如果需要）

**验证**：
```bash
docker-compose up -d surrealdb
docker ps | grep surrealdb_QTRAN
```

---

## 2. 数据库连接参数配置 ✅

### 文件：`src/Tools/DatabaseConnect/database_connector_args.json`

**目的**：配置数据库连接信息

**位置**：在 JSON 对象中新增一个键
```json
{
  "surrealdb": {
    "container_name": "surrealdb_QTRAN",
    "dbType": "surrealdb",
    "host": "127.0.0.1",
    "port": 8000,
    "container_port": 8000,
    "username": "root",
    "password": "root",
    "namespace": "test",
    "database": "test"
  }
}
```

**关键点**：
- `container_name` 必须与 docker-compose.yml 中一致
- `dbType` 用于代码中识别数据库类型
- 根据数据库特性添加特有字段（如 SurrealDB 的 namespace）

---

## 3. 数据库连接器代码 ✅

### 文件：`src/Tools/DatabaseConnect/database_connector.py`

**需要修改 3 个位置**：

### 3.1 `__init__` 方法
```python
def __init__(
    self,
    container_name,
    dbType,
    host,
    port=None,
    username=None,
    password=None,
    database=None,
    **kwargs  # ← 接收额外参数
):
    # ... 现有代码 ...
    self.kwargs = kwargs  # ← 存储额外参数
```

### 3.2 `create_engine` 方法
```python
def create_engine(self):
    # ... 现有分支 ...
    
    elif self.dbType == "SURREALDB":  # ← 新增分支
        # SurrealDB 使用 HTTP API，不需要 SQLAlchemy
        self.engine = None
        self.surrealdb_url = f"http://{self.host}:{self.port}/sql"
        self.surrealdb_auth = (self.username, self.password)
        self.surrealdb_namespace = self.kwargs.get('namespace', 'test')
        self.surrealdb_database = self.kwargs.get('database', 'test')
        self.surrealdb_headers = {
            "NS": self.surrealdb_namespace,
            "DB": self.surrealdb_database,
            "Accept": "application/json"
        }
        print(f"✅ SurrealDB connection configured: {self.surrealdb_url}")
```

### 3.3 `execSQL` 方法
```python
def execSQL(self, sql_statement, fetch=True, timeout=60):
    # ... 现有分支 ...
    
    elif self.dbType == "SURREALDB":  # ← 新增分支
        import requests
        try:
            response = requests.post(
                self.surrealdb_url,
                data=sql_statement,
                auth=self.surrealdb_auth,
                headers=self.surrealdb_headers,
                timeout=timeout
            )
            
            if response.status_code != 200:
                error_msg = f"HTTP {response.status_code}: {response.text}"
                raise Exception(error_msg)
            
            result = response.json()
            # 转换为 SQLAlchemy 格式
            if isinstance(result, list) and len(result) > 0:
                first_result = result[0]
                if first_result.get("status") == "OK":
                    rows = first_result.get("result", [])
                    return rows
            return []
            
        except Exception as e:
            raise Exception(f"SurrealDB error: {str(e)}")
```

### 3.4 `check_connection` 方法
```python
def check_connection(self):
    if self.dbType == "SURREALDB":  # ← 新增分支
        import requests
        try:
            health_url = f"http://{self.host}:{self.port}/health"
            response = requests.get(health_url, timeout=5)
            if response.status_code == 200:
                print(f"✅ SurrealDB connection OK")
                return True
        except:
            pass
        return False
    
    # ... 现有代码（SQLAlchemy 引擎检查）...
```

### 3.5 `database_clear` 函数
```python
def database_clear(dbType, ip, port, username, password, database, **kwargs):
    # ... 现有分支 ...
    
    elif dbType.lower() == "surrealdb":  # ← 新增分支
        import requests
        namespace = kwargs.get('namespace', 'test')
        url = f"http://{ip}:{port}/sql"
        headers = {"NS": namespace, "DB": database, "Accept": "application/json"}
        sql = f"REMOVE DATABASE {database};"
        response = requests.post(
            url, 
            data=sql, 
            auth=(username, password), 
            headers=headers
        )
        if response.status_code == 200:
            print(f"✅ Cleared SurrealDB database: {database}")
```

**关键点**：
- 根据数据库特性选择连接方式（SQLAlchemy 或 HTTP API）
- 统一返回格式（列表形式）
- 处理数据库特有的认证和配置

---

## 4. 知识库创建 ✅

### 目录：`NoSQLFeatureKnowledgeBase/[DatabaseName]/`

**需要创建的文件**（以 SurrealDB 为例）：

### 4.1 `sql_to_[database]_mapping.json`
存储 SQL 到目标数据库的映射规则

```json
{
  "critical_syntax_differences": {
    "CREATE_TABLE": {
      "sqlite_pattern": "CREATE TABLE table (col TYPE)",
      "surrealdb_pattern": "DEFINE TABLE table SCHEMAFULL; DEFINE FIELD col ...",
      "severity": "CRITICAL",
      "common_errors": ["CREATE TABLE t0 (c0 STRING)"],
      "correct_translations": [
        {
          "input": "CREATE TABLE t0(c0);",
          "output": "DEFINE TABLE t0 SCHEMAFULL; DEFINE FIELD c0 ..."
        }
      ],
      "notes": "完全不同的语法"
    }
  },
  "type_mappings": {
    "INTEGER": "int",
    "TEXT": "string",
    "REAL": "float"
  },
  "aggregate_functions": {
    "COUNT(*)": {
      "surrealdb": "count()",
      "notes": "No asterisk"
    },
    "AVG(x)": {
      "surrealdb": "math::mean(x)",
      "notes": "Must use math::mean"
    }
  },
  "unsupported_features": {
    "PRAGMA": {
      "reason": "SQLite-specific",
      "action": "Return comment",
      "examples": ["PRAGMA encoding = 'UTF16be';"]
    }
  },
  "identical_syntax": {
    "SELECT": "SELECT * FROM table WHERE ...",
    "INSERT": "INSERT INTO table VALUES (...)",
    "UPDATE": "UPDATE table SET ... WHERE ..."
  }
}
```

### 4.2 `[database]_translation_rules.json`
结构化的翻译规则

```json
{
  "database": "SurrealDB",
  "version": "2.3.10",
  "query_language": "SurrealQL",
  "translation_rules": [
    {
      "rule_id": "CREATE_TABLE_CRITICAL",
      "priority": "CRITICAL",
      "category": "DDL",
      "sqlite_pattern": "CREATE TABLE {table} ({columns})",
      "surrealdb_pattern": "DEFINE TABLE {table} SCHEMAFULL; ...",
      "description": "完全不同的语法",
      "examples": [
        {
          "input": "CREATE TABLE t0(c0);",
          "output": "DEFINE TABLE t0 SCHEMAFULL; ...",
          "explanation": "必须拆分为多个语句"
        }
      ],
      "common_errors": ["CREATE TABLE t0 (c0 STRING)"]
    },
    {
      "rule_id": "COUNT_ASTERISK",
      "priority": "HIGH",
      "category": "Aggregate",
      "sqlite_pattern": "COUNT(*)",
      "surrealdb_pattern": "count()",
      "description": "去掉星号"
    }
  ]
}
```

**关键内容**：
- 关键语法差异（标记 severity）
- 类型映射
- 函数映射
- 不支持的特性
- 相同语法（可选）
- 翻译示例

---

## 5. 知识库导入器集成 ✅

### 文件：`tools/knowledge_base_importer.py`

**需要修改 4 个位置**：

### 5.1 添加导入方法
```python
def import_surrealdb_knowledge(self):
    """导入 SurrealDB 知识库"""
    print("\n📚 Importing SurrealDB knowledge...")
    db_name = "surrealdb"
    
    # 1. 导入 SQL 到 SurrealDB 映射
    mapping_path = self.base_path / "NoSQLFeatureKnowledgeBase/SurrealDB/sql_to_surrealdb_mapping.json"
    if mapping_path.exists():
        with open(mapping_path, 'r', encoding='utf-8') as f:
            mapping_data = json.load(f)
        
        # 导入关键语法差异
        if "critical_syntax_differences" in mapping_data:
            for feature_name, feature_info in mapping_data["critical_syntax_differences"].items():
                memory_text = self._format_surrealdb_critical_syntax(feature_name, feature_info)
                metadata = {
                    "database": db_name,
                    "type": "critical_syntax",
                    "feature_name": feature_name,
                    "severity": feature_info.get("severity", "HIGH"),
                    "source": "sql_mapping"
                }
                self._add_memory(memory_text, db_name, metadata)
        
        # ... 导入其他类型 ...
```

### 5.2 添加格式化方法
```python
def _format_surrealdb_critical_syntax(self, feature_name: str, feature_info: Dict) -> str:
    """格式化 SurrealDB 关键语法差异"""
    parts = [f"🔴 CRITICAL: {feature_name} - 语法完全不同！"]
    parts.append(f"SQLite: {feature_info.get('sqlite_pattern', 'N/A')}")
    parts.append(f"SurrealDB: {feature_info.get('surrealdb_pattern', 'N/A')}")
    
    if feature_info.get("common_errors"):
        parts.append("常见错误:")
        for err in feature_info["common_errors"][:3]:
            parts.append(f"  ❌ {err}")
    
    if feature_info.get("correct_translations"):
        parts.append("正确翻译:")
        for trans in feature_info["correct_translations"][:3]:
            parts.append(f"  ✅ {trans['input']} → {trans['output']}")
    
    return "\n".join(parts)

# ... 其他格式化方法 ...
```

### 5.3 添加命令行参数
```python
def main():
    parser = argparse.ArgumentParser(description="Import knowledge bases to Mem0")
    parser.add_argument("--nosql", 
                       choices=["mongodb", "redis", "surrealdb"],  # ← 添加新数据库
                       help="Import specific NoSQL database")
```

### 5.4 添加主函数分支
```python
elif args.nosql:
    if args.nosql == "mongodb":
        importer.import_mongodb_knowledge()
    elif args.nosql == "redis":
        importer.import_redis_knowledge()
    elif args.nosql == "surrealdb":  # ← 新增分支
        importer.import_surrealdb_knowledge()
```

---

## 6. 翻译流程集成 ✅

### 文件：`src/TransferLLM/TransferLLM.py`

**需要修改 4 个位置**：

### 6.1 在 `get_NoSQL_knowledge_string()` 中添加加载逻辑
```python
def get_NoSQL_knowledge_string(origin_db, target_db, with_knowledge, sql_statement_processed):
    # ... 现有代码 ...
    
    nosql_targets = {"redis", "mongodb", "surrealdb"}  # ← 添加新数据库
    
    # === SurrealDB 知识库加载 ===
    if str(target_db).lower() == "surrealdb":
        try:
            repo_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            mapping_path = os.path.join(
                repo_root,
                "NoSQLFeatureKnowledgeBase",
                "SurrealDB",
                "sql_to_surrealdb_mapping.json"
            )
            
            if os.path.exists(mapping_path):
                with open(mapping_path, "r", encoding="utf-8") as f:
                    surrealdb_kb = json.load(f)
                
                knowledge_string += "\n========== 🔴 CRITICAL SurrealDB Syntax Rules ==========\n\n"
                
                # 1. 关键语法差异
                if "critical_syntax_differences" in surrealdb_kb:
                    create_table_info = surrealdb_kb["critical_syntax_differences"].get("CREATE_TABLE", {})
                    knowledge_string += "⚠️  CREATE TABLE Syntax (MOST IMPORTANT!):\n\n"
                    knowledge_string += f"SQLite: {create_table_info.get('sqlite_pattern')}\n"
                    knowledge_string += f"SurrealDB: {create_table_info.get('surrealdb_pattern')}\n\n"
                    knowledge_string += "❌ WRONG Examples:\n"
                    for err in create_table_info.get("common_errors", [])[:3]:
                        knowledge_string += f"  - {err}\n"
                    knowledge_string += "\n✅ CORRECT Examples:\n"
                    for trans in create_table_info.get("correct_translations", [])[:3]:
                        knowledge_string += f"  Input:  {trans['input']}\n"
                        knowledge_string += f"  Output: {trans['output']}\n\n"
                
                # 2. 类型映射
                if "type_mappings" in surrealdb_kb:
                    knowledge_string += "Type Mappings:\n"
                    for sql_type, surreal_type in surrealdb_kb["type_mappings"].items():
                        knowledge_string += f"  {sql_type} → {surreal_type}\n"
                
                # 3. 聚合函数
                if "aggregate_functions" in surrealdb_kb:
                    knowledge_string += "\nAggregate Functions:\n"
                    for func_name, func_info in surrealdb_kb["aggregate_functions"].items():
                        knowledge_string += f"  {func_name} → {func_info.get('surrealdb')}\n"
                
                knowledge_string += "\n========================================\n\n"
                print(f"✅ Loaded SurrealDB knowledge base")
        
        except Exception as e:
            print(f"❌ Failed to load SurrealDB knowledge: {e}")
    
    elif str(origin_db).lower() == "redis":
        # ... Redis 逻辑 ...
```

### 6.2 在 `transfer_llm_sql_semantic()` 中更新 NOSQL_DBS
```python
def transfer_llm_sql_semantic(...):
    # ... 代码 ...
    
    if with_knowledge:
        NOSQL_DBS = {"redis", "memcached", "etcd", "consul", "mongodb", "surrealdb"}  # ← 添加
        if str(origin_db).lower() in NOSQL_DBS or str(target_db).lower() in NOSQL_DBS:
            feature_knowledge_string = get_NoSQL_knowledge_string(...)
```

### 6.3 在 `transfer_llm_nosql_crash()` 中更新 NOSQL_DBS
```python
def transfer_llm_nosql_crash(...):
    # ... 代码 ...
    
    NOSQL_DBS = {"redis", "memcached", "etcd", "consul", "mongodb", "surrealdb"}  # ← 添加
```

**关键点**：
- 在 Prompt 中**显著标记**关键差异（使用 🔴、⚠️、❌、✅ 等符号）
- 提供错误示例和正确示例对比
- 按重要性排序（CRITICAL 优先）

---

## 7. 预处理脚本（可选）⚙️

### 场景：源数据库有不可翻译的语句

如果源数据库（如 SQLite）有目标数据库不支持的特性（如 PRAGMA），创建过滤脚本：

### 文件：`scripts/[database]/filter_[source]_sql.py`

```python
#!/usr/bin/env python3
"""
过滤 SQLite SQL 语句，去除 SurrealDB 不支持的特性
"""
import json
import re

def is_untranslatable(sql_statement):
    """检查 SQL 是否不可翻译"""
    sql_upper = sql_statement.strip().upper()
    
    # PRAGMA 命令
    if sql_upper.startswith('PRAGMA'):
        return True, "PRAGMA command"
    
    # ATTACH/DETACH DATABASE
    if 'ATTACH DATABASE' in sql_upper or 'DETACH DATABASE' in sql_upper:
        return True, "ATTACH/DETACH DATABASE"
    
    # VACUUM
    if sql_upper.startswith('VACUUM'):
        return True, "VACUUM command"
    
    return False, None

def filter_jsonl_file(input_file, output_file):
    """过滤 JSONL 文件"""
    filtered_count = 0
    total_count = 0
    
    with open(input_file, 'r', encoding='utf-8') as fin, \
         open(output_file, 'w', encoding='utf-8') as fout:
        
        for line in fin:
            total_count += 1
            data = json.loads(line.strip())
            
            # 检查 sql 或 sqls 字段
            if 'sqls' in data:
                filtered_sqls = []
                for sql in data['sqls']:
                    is_untr, reason = is_untranslatable(sql)
                    if not is_untr:
                        filtered_sqls.append(sql)
                    else:
                        print(f"🚫 Filtered: {sql[:60]}... ({reason})")
                
                if filtered_sqls:
                    data['sqls'] = filtered_sqls
                    fout.write(json.dumps(data, ensure_ascii=False) + '\n')
                else:
                    filtered_count += 1
            
            elif 'sql' in data:
                is_untr, reason = is_untranslatable(data['sql'])
                if not is_untr:
                    fout.write(line)
                else:
                    filtered_count += 1
                    print(f"🚫 Filtered: {data['sql'][:60]}... ({reason})")
    
    print(f"\n统计: 总共 {total_count} 条，过滤 {filtered_count} 条")

if __name__ == "__main__":
    filter_jsonl_file("Input/demo1.jsonl", "Input/demo1_surrealdb_filtered.jsonl")
```

---

## 8. 测试验证 ✅

### 8.1 测试数据库连接
```python
# test_[database]_connection.py
import requests

url = "http://127.0.0.1:8000/sql"
auth = ("root", "root")
headers = {"NS": "test", "DB": "test", "Accept": "application/json"}

# 测试基本查询
response = requests.post(url, data="INFO FOR DB;", auth=auth, headers=headers)
print(response.json())

# 测试表创建
sql = "DEFINE TABLE test SCHEMAFULL; DEFINE FIELD name ON TABLE test TYPE string;"
response = requests.post(url, data=sql, auth=auth, headers=headers)
print(response.json())
```

### 8.2 运行翻译测试
```bash
cd /root/QTRAN
source venv/bin/activate

# 运行测试（使用过滤后的输入）
python -m src.main \
    --input_filename Input/demo1_surrealdb_filtered.jsonl \
    --tool sqlancer \
    --model gpt-4o-mini \
    --temperature 0.3
```

### 8.3 验证知识库加载
查看日志中是否有：
```
✅ Loaded SurrealDB knowledge base from: .../sql_to_surrealdb_mapping.json
```

### 8.4 检查翻译结果
```bash
# 查看输出文件
cat Output/demo1_surrealdb_filtered/sqlancer_surrealdb/results.jsonl

# 检查是否还有语法错误
grep "CREATE TABLE.*(" Output/demo1_surrealdb_filtered/sqlancer_surrealdb/results.jsonl
```

---

## 📊 完整性检查清单

使用此清单确保所有步骤完成：

### Docker & 配置
- [ ] `docker-compose.yml` 添加服务定义
- [ ] `database_connector_args.json` 添加连接参数
- [ ] 容器可以正常启动

### 代码集成
- [ ] `database_connector.py` - `__init__` 接收额外参数
- [ ] `database_connector.py` - `create_engine` 添加分支
- [ ] `database_connector.py` - `execSQL` 添加分支
- [ ] `database_connector.py` - `check_connection` 添加分支
- [ ] `database_connector.py` - `database_clear` 添加分支

### 知识库
- [ ] 创建 `NoSQLFeatureKnowledgeBase/[Database]/` 目录
- [ ] 创建 `sql_to_[database]_mapping.json`
- [ ] 创建 `[database]_translation_rules.json`
- [ ] 包含关键语法差异
- [ ] 包含类型映射
- [ ] 包含函数映射
- [ ] 包含不支持的特性

### 导入器
- [ ] `knowledge_base_importer.py` - 添加导入方法
- [ ] `knowledge_base_importer.py` - 添加格式化方法（至少 3-5 个）
- [ ] `knowledge_base_importer.py` - 更新命令行参数
- [ ] `knowledge_base_importer.py` - 添加主函数分支

### 翻译流程
- [ ] `TransferLLM.py` - `get_NoSQL_knowledge_string()` 添加加载逻辑
- [ ] `TransferLLM.py` - 更新 `nosql_targets` 集合
- [ ] `TransferLLM.py` - `transfer_llm_sql_semantic()` 更新 NOSQL_DBS
- [ ] `TransferLLM.py` - `transfer_llm_nosql_crash()` 更新 NOSQL_DBS
- [ ] Prompt 中显著标记关键差异

### 可选
- [ ] 创建预处理脚本（如需要）
- [ ] 创建测试脚本

### 验证
- [ ] 数据库连接测试通过
- [ ] 知识库成功加载（日志确认）
- [ ] 翻译能生成正确语法
- [ ] 没有重复的语法错误

---

## 💡 最佳实践

### 1. 优先级顺序
1. **CRITICAL** - 完全不同的语法（如 CREATE TABLE）
2. **HIGH** - 常用功能的差异（如聚合函数）
3. **MEDIUM** - 类型映射
4. **LOW** - 相同或相似的语法

### 2. Prompt 设计原则
- ✅ 使用醒目符号（🔴、⚠️、❌、✅）
- ✅ 错误示例 vs 正确示例对比
- ✅ 简洁明了，避免冗长描述
- ✅ 按重要性排序

### 3. 知识库组织
- ✅ 关键信息放在 JSON 顶层
- ✅ 使用结构化字段（severity, priority, category）
- ✅ 提供具体示例而非抽象描述

### 4. 错误处理
- ✅ 加载知识库失败时不阻塞流程
- ✅ 记录详细日志便于调试
- ✅ 提供降级方案（如不加载知识库也能运行）

---

## 🔍 调试技巧

### 检查知识库是否加载
```python
# 在 TransferLLM.py 的 get_NoSQL_knowledge_string() 中添加：
print(f"📋 Knowledge string length: {len(knowledge_string)}")
print(f"📋 First 500 chars: {knowledge_string[:500]}")
```

### 检查 Prompt 内容
```python
# 在 transfer_llm_sql_semantic() 中添加：
print("=" * 80)
print("FINAL PROMPT:")
print(prompt_template.format(
    examples_string=examples_string,
    feature_knowledge_string=feature_knowledge_string,
    ...
))
print("=" * 80)
```

### 检查翻译结果
```bash
# 查看最近的翻译结果
tail -n 20 Output/*/sqlancer_*/results.jsonl

# 统计错误类型
grep -o "Parse error.*" nohup.out | sort | uniq -c
```

---

## 📚 参考示例

完整的 SurrealDB 集成参考：
- `docker-compose.yml` - lines 100-110
- `database_connector_args.json` - surrealdb 条目
- `database_connector.py` - 搜索 "SURREALDB"
- `NoSQLFeatureKnowledgeBase/SurrealDB/` - 所有文件
- `knowledge_base_importer.py` - `import_surrealdb_knowledge()`
- `TransferLLM.py` - line 710-776

---

## ⚠️ 常见陷阱

1. **忘记更新所有 NOSQL_DBS 集合** → 导致知识库不加载
2. **知识库路径错误** → 文件找不到但不报错
3. **Docker 网络配置错误** → 容器间无法通信
4. **Prompt 格式问题** → LLM 无法理解关键信息
5. **类型映射不完整** → 部分类型翻译错误

---

## 🎓 总结

新增数据库的核心是：
1. **让 QTRAN 能连上**（Docker + 连接器）
2. **让 LLM 知道怎么翻译**（知识库 + Prompt）
3. **让系统认识它是 NoSQL**（更新集合和分支判断）

按照此清单逐项完成，新数据库就能顺利集成到 QTRAN 中！


{"index": 2001, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE test (c0);", "CREATE INDEX index_0 ON test(c0 LIKE '');", "PRAGMA case_sensitive_like=false;", "VACUUM;", "SELECT * from test; -- Error: malformed database schema (index_0) - non-deterministic functions prohibited in index expressions"]}
{"index": 2002, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE test (c0 REAL);", "CREATE INDEX index_0 ON test(c0 COLLATE NOCASE);", "INSERT INTO test(c0) VALUES ('+/');", "SELECT * FROM test WHERE (c0 LIKE '+/'); -- fetches no row"]}
{"index": 2003, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE INDEX index_0 ON t0(c0) WHERE (~c0) NOT NULL;", "INSERT INTO t0(c0) VALUES (NULL);", "SELECT * FROM t0 WHERE (LIKELY(~c0) OR TRUE); -- no row fetched"]}
{"index": 2004, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["PRAGMA foreign_keys=true;", "CREATE TABLE t0 (c0 UNIQUE, c1 UNIQUE, FOREIGN KEY(c0) REFERENCES t0(c1));", "INSERT OR FAIL INTO t0(c0, c1) VALUES (0, 1);", "INSERT OR FAIL INTO t0(c0, c1) VALUES (0, 2);", "SELECT * FROM t0; -- returns no row"]}
{"index": 2005, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE TABLE t1(c0 INTEGER PRIMARY KEY);", "PRAGMA reverse_unordered_selects=true;", "INSERT INTO t1(c0) VALUES (0);", "INSERT INTO t0(c0) VALUES ('a');", "SELECT * FROM t1, t0 WHERE t1.c0 < t0.c0; -- no row is fetched"]}
{"index": 2006, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT UNIQUE COLLATE NOCASE);", "INSERT INTO t0(c0) VALUES ('./');", "SELECT * FROM t0 WHERE t0.c0 LIKE './'; -- fetches no rows"]}
{"index": 2007, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INTEGER PRIMARY KEY);", "INSERT INTO t0(c0) VALUES (1);", "PRAGMA reverse_unordered_selects=true;", "SELECT * FROM t0 WHERE ((t0.c0 > 'a') OR (t0.c0 <= 'a')); -- fetches no row", "SELECT ((t0.c0 > 'a') OR (t0.c0 <= 'a')) FROM t0; -- returns 1"]}
{"index": 2008, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE IF NOT EXISTS t0 (c0);", "CREATE INDEX IF NOT EXISTS i0 ON t0(1) WHERE c0 NOT NULL;", "INSERT INTO t0(c0) VALUES(NULL);", "SELECT * FROM t0 WHERE t0.c0 IS NOT 1; -- returns no row"]}
{"index": 2009, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["PRAGMA reverse_unordered_selects=true;", "CREATE TABLE t1 (c0, c1); CREATE TABLE t2 (c0 INT UNIQUE);", "INSERT INTO t1(c0, c1) VALUES (0, 0), (0, NULL);", "INSERT INTO t2(c0) VALUES (1);", "SELECT 1, NULL INTERSECT SELECT * FROM (SELECT t2.c0, t1.c1 FROM t1, t2 WHERE ((t2.rowid <= 'a')) OR (t1.c0 <= t2.c0) ORDER BY 'a' DESC LIMIT 100); -- no row is fetched"]}
{"index": 2010, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0);", "CREATE TABLE t1 (c1 REAL);", "INSERT INTO t1(c1) VALUES (8366271098608253588);", "INSERT INTO t0(c0) VALUES ('a');", "SELECT * FROM t1 WHERE (t1.c1 = CAST(8366271098608253588 AS REAL)); -- fetches row", "SELECT * FROM t0, t1 WHERE (t1.c1 = CAST(8366271098608253588 AS REAL)); -- fetches no row", "SELECT * FROM t0, t1 WHERE (t1.c1 >= CAST(8366271098608253588 AS REAL) AND t1.c1 <= CAST(8366271098608253588 AS REAL)); -- fetches row"]}
{"index": 2011, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0, c1, PRIMARY KEY (c0, c1));", "CREATE TABLE t1 (c0);", "INSERT INTO t1 VALUES (2);", "SELECT * FROM t0, t1 WHERE (t0.c1 >= 1 OR t0.c1 < 1) AND t0.c0 IN (1, t1.c0) ORDER BY 1; -- results in a segfault"]}
{"index": 2012, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c1, c2);", "INSERT INTO t0(c1, c2) VALUES  ('a', 1);", "CREATE INDEX i0 ON t0(\"C3\");", "ALTER TABLE t0 RENAME COLUMN c1 TO c3;", "SELECT DISTINCT * FROM t0; -- fetches C3|1 rather than a|1"]}
{"index": 2013, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "INSERT INTO t0(c0) VALUES ('val');", "SELECT * FROM t0 WHERE (((0 IS NOT FALSE) OR NOT (0 IS FALSE OR (t0.c0 IN (-1)))) IS 0); -- fetches no row"]}
{"index": 2014, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0 TEXT);", "INSERT INTO t0(c0) VALUES ('1.0');", "SELECT CAST(c0 AS NUMERIC) FROM t0; -- expected: 1, actual: 1.0"]}
{"index": 2015, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT PRIMARY KEY COLLATE NOCASE);", "INSERT INTO t0 VALUES (' 1-');", "SELECT * FROM t0 WHERE t0.c0 LIKE ' 1-'; -- expected: ' 1-', actual: no row is fetched"]}
{"index": 2016, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 COLLATE NOCASE);", "INSERT INTO t0(c0) VALUES ('a');", "SELECT * FROM t0 WHERE CAST(t0.c0 AS TEXT) = 'A'; -- expected: no row is fetched, actual: a"]}
{"index": 2017, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT UNIQUE COLLATE NOCASE);", "INSERT INTO t0(c0) VALUES ('.1%');", "SELECT * FROM t0 WHERE t0.c0 LIKE '.1%'; -- expected: '.1%', actual: no row is fetched"]}
{"index": 2018, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c3 TEXT);", "INSERT INTO t0(c3) VALUES ('0');", "SELECT * FROM t0 WHERE (t0.c3 COLLATE NOCASE) BETWEEN 1 AND '5'; -- expected: no row is fetched, actual: row is fetched"]}
{"index": 2019, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TINYINT);", "INSERT INTO t0(c0) VALUES(NULL);", "SELECT * FROM t0 WHERE NOT(t0.c0 <=> 2035382037); -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2020, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TINYINT);", "INSERT INTO t0(c0) VALUES(NULL);", "SELECT * FROM t0 WHERE NOT(t0.c0 <=> 2035382037); -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2021, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0(c0) VALUES(1);", "SELECT * FROM t0 WHERE IF(FALSE, t0.c0, 0.1); -- expected: row is fetched, actual: row is not fetched"]}
{"index": 2022, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0(c0) VALUES(1);", "SELECT * FROM t0 WHERE IF(FALSE, t0.c0, 0.1); -- expected: row is fetched, actual: row is not fetched"]}
{"index": 2023, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT) ENGINE = MyISAM;", "select * from information_schema.TABLES; -- unexpected (when executed with multiple threads): Duplicate entry 'triggerbug21-t0' for key 'PRIMARY'"]}
{"index": 2024, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT) ENGINE = MyISAM;", "select * from information_schema.TABLES; -- unexpected (when executed with multiple threads): Duplicate entry 'triggerbug21-t0' for key 'PRIMARY'"]}
{"index": 2025, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "INSERT IGNORE INTO t0(c0) VALUES(\"\\n123\");", "SELECT * FROM t0 WHERE COALESCE(t0.c0); -- expected: row is fetched, actual: no row is fetched", "SELECT * FROM t0 WHERE IFNULL(t0.c0, 1); -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2026, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "INSERT IGNORE INTO t0(c0) VALUES(\"\\n123\");", "SELECT * FROM t0 WHERE COALESCE(t0.c0); -- expected: row is fetched, actual: no row is fetched", "SELECT * FROM t0 WHERE IFNULL(t0.c0, 1); -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2027, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES(0.9);", "SELECT * FROM t0 WHERE t0.c0; -- expected: row is fetched, actual: row is not fetched"]}
{"index": 2028, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES(0.9);", "SELECT * FROM t0 WHERE t0.c0; -- expected: row is fetched, actual: row is not fetched"]}
{"index": 2029, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BIGINT UNSIGNED);", "INSERT INTO t0(c0) VALUES(NULL);", "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- expected: row is selected, actual: no row is selected", "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- expected: row is selected, actual: no row is selected"]}
{"index": 2030, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BIGINT UNSIGNED);", "INSERT INTO t0(c0) VALUES(NULL);", "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- expected: row is selected, actual: no row is selected", "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- expected: row is selected, actual: no row is selected"]}
{"index": 2031, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES(\"0.5\");", "SELECT * FROM t0 WHERE t0.c0 AND 1; -- expected: 0.5, actual: no row is fetched", "SELECT * FROM t0 WHERE t0.c0 OR 0; -- expected: 0.5, actual: no row is fetched", "SELECT * FROM t0 WHERE t0.c0 XOR 0;  -- expected: 0.5, actual: no row is fetched"]}
{"index": 2032, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES(\"0.5\");", "SELECT * FROM t0 WHERE t0.c0 AND 1; -- expected: 0.5, actual: no row is fetched", "SELECT * FROM t0 WHERE t0.c0 OR 0; -- expected: 0.5, actual: no row is fetched", "SELECT * FROM t0 WHERE t0.c0 XOR 0;  -- expected: 0.5, actual: no row is fetched"]}
{"index": 2033, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT) ENGINE = MEMORY;", "INSERT INTO t0(c0) VALUES(0);", "INSERT INTO t1(c0) VALUES(-1);", "SELECT * FROM t0, t1 WHERE (CAST(t1.c0 AS UNSIGNED)) > (IFNULL(\"u\", t0.c0)); -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2034, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT) ENGINE = MEMORY;", "INSERT INTO t0(c0) VALUES(0);", "INSERT INTO t1(c0) VALUES(-1);", "SELECT * FROM t0, t1 WHERE (CAST(t1.c0 AS UNSIGNED)) > (IFNULL(\"u\", t0.c0)); -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2035, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["SET SESSION sort_buffer_size = 18446744073709551615;", "CREATE TABLE t0(c0 INT UNIQUE, c1 INT UNIQUE);", "INSERT INTO t0(c0) VALUES(1), (2), (3);", "SELECT * FROM t0 WHERE NOT((t0.c1 IS NULL) AND ((t0.c0) != (1))); -- unexpected: ERROR 5 (HY000): Out of memory (Needed 24 bytes)"]}
{"index": 2036, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["SET SESSION sort_buffer_size = 18446744073709551615;", "CREATE TABLE t0(c0 INT UNIQUE, c1 INT UNIQUE);", "INSERT INTO t0(c0) VALUES(1), (2), (3);", "SELECT * FROM t0 WHERE NOT((t0.c1 IS NULL) AND ((t0.c0) != (1))); -- unexpected: ERROR 5 (HY000): Out of memory (Needed 24 bytes)"]}
{"index": 2037, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT, c1 TEXT);", "INSERT INTO t0(c0, c1) VALUES(-1, \"a\");", "SELECT * FROM t0 WHERE t0.c1 < (t0.c0 & t0.c0) AND t0.c0 = -1; -- expected: fetches row, actual: does not fetch the row"]}
{"index": 2038, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT, c1 TEXT);", "INSERT INTO t0(c0, c1) VALUES(-1, \"a\");", "SELECT * FROM t0 WHERE t0.c1 < (t0.c0 & t0.c0) AND t0.c0 = -1; -- expected: fetches row, actual: does not fetch the row"]}
{"index": 2039, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES (\"a\");", "SELECT * FROM t0 WHERE GREATEST((-1) & (-1), -t0.c0); -- expected: row is fetched, actual: row is not fetched"]}
{"index": 2040, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES (\"a\");", "SELECT * FROM t0 WHERE GREATEST((-1) & (-1), -t0.c0); -- expected: row is fetched, actual: row is not fetched"]}
{"index": 2041, "a_db": "postgresql", "b_db": "duckdb", "molt": "norec", "sqls": ["-- requires another open transaction holding a snapshot", "CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES('b'), ('a');", "ANALYZE;", "INSERT INTO t0(c0) VALUES (NULL);", "UPDATE t0 SET c0 = 'a';", "CREATE INDEX i0 ON t0(c0);", "SELECT * FROM t0 WHERE 'baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' > t0.c0; -- unexpected: ERROR: found unexpected null value in index \"i0\""]}
{"index": 2042, "a_db": "postgresql", "b_db": "cockroachdb", "molt": "norec", "sqls": ["-- requires another open transaction holding a snapshot", "CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES('b'), ('a');", "ANALYZE;", "INSERT INTO t0(c0) VALUES (NULL);", "UPDATE t0 SET c0 = 'a';", "CREATE INDEX i0 ON t0(c0);", "SELECT * FROM t0 WHERE 'baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' > t0.c0; -- unexpected: ERROR: found unexpected null value in index \"i0\""]}
{"index": 2043, "a_db": "postgresql", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BOOLEAN, c1 BOOLEAN, UNIQUE(c1));", "CREATE STATISTICS s1 ON c0, c1 FROM t0;", "INSERT INTO t0(c0) VALUES(TRUE);", "ANALYZE t0;", "SELECT * FROM t0 WHERE (t0.c0 AND t0.c1) >= TRUE; -- ERROR:  negative bitmapset member not allowed"]}
{"index": 2044, "a_db": "postgresql", "b_db": "cockroachdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BOOLEAN, c1 BOOLEAN, UNIQUE(c1));", "CREATE STATISTICS s1 ON c0, c1 FROM t0;", "INSERT INTO t0(c0) VALUES(TRUE);", "ANALYZE t0;", "SELECT * FROM t0 WHERE (t0.c0 AND t0.c1) >= TRUE; -- ERROR:  negative bitmapset member not allowed"]}
{"index": 2045, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0, c1, c2, PRIMARY KEY (c0, c1));", "CREATE TABLE t1 (c2);", "INSERT INTO t0(c2) VALUES (0), (1), (3), (4), (5), (6), (7), (8), (9), (10), (11);", "INSERT INTO t0(c1) VALUES ('a');", "INSERT INTO t1(c2) VALUES (0);", "ANALYZE;", "SELECT DISTINCT t0.c0, t1._rowid_, t0.c1 FROM t1 CROSS JOIN t0 ON TRUE ORDER BY t0.c0; -- expected: |1|, |1|a, actual: |1|"]}
{"index": 2046, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t1 (c1 , c2, c3, c4 , PRIMARY KEY (c4, c3));", "INSERT INTO t1(c3) VALUES (0), (0), (0), (0), (0), (0), (0), (0), (0), (0), (NULL), (1), (0);", "UPDATE t1 SET c2 = 0;", "INSERT INTO t1(c1) VALUES (0), (0), (NULL), (0), (0);", "ANALYZE t1;", "UPDATE t1 SET c3 = 1;", "SELECT DISTINCT * FROM t1 WHERE t1.c3 = 1; -- expected: |0|1|, 0||1|, ||1|, actual: |0|1|"]}
{"index": 2047, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 UNIQUE, c1);", "INSERT INTO t0(c0, c1) VALUES (NULL, 1);", "SELECT MIN(t0.c0), t0.c1 FROM t0; -- expected: NULL | 1, actual: NULL | NULL"]}
{"index": 2048, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0, c1);", "CREATE INDEX i0 ON t0(c1, c1 + 1 DESC);", "INSERT INTO t0(c0) VALUES (1);", "SELECT MIN(t0.c1), t0.c0 FROM t0 WHERE t0.c1 ISNULL; -- expected: NULL | 1, actual: NULL | NULL"]}
{"index": 2049, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0, c1 TEXT);", "CREATE VIEW v0(c0) AS SELECT SUM(t0.c1) FROM t0;", "INSERT INTO t0(c0, c1) VALUES ('a', 1);", "SELECT * FROM v0, t0 WHERE t0.c1 <= v0.c0; -- unexpected: row is not fetched"]}
{"index": 2050, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT, c1);", "INSERT INTO t0(c0, c1) VALUES (-1, 0);", "CREATE VIEW v0(c0, c1) AS SELECT t0.c0, AVG(t0.c1) FROM t0;", "SELECT * FROM v0 WHERE v0.c1 < v0.c0; -- unexpected: row is not fetched"]}
{"index": 2051, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "CREATE VIEW v0(c0) AS SELECT t0.c0 FROM t0;", "INSERT INTO t0(c0) VALUES ('0');", "SELECT 0 IN (c0) FROM v0; -- expected: 0, actual: 1"]}
{"index": 2052, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 UNIQUE, c1);", "INSERT INTO t0(c1) VALUES (0);", "INSERT INTO t0(c0) VALUES (0);", "CREATE VIEW v0(c0, c1) AS SELECT t0.c1, t0.c0 FROM t0 WHERE CAST(t0.rowid AS INT) = 1;", "SELECT v0.c0, MIN(v0.c1) FROM v0; -- expected: 0|, actual: |"]}
{"index": 2053, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "INSERT INTO t0(c0) VALUES (0);", "CREATE INDEX i0 ON t0(NULL > c0) WHERE (NULL NOT NULL);", "SELECT * FROM t0 WHERE ((NULL IS FALSE) IS FALSE); -- expected: row is fetched: actual: row is not fetched"]}
{"index": 2054, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "INSERT INTO t0(c0) VALUES (0);", "SELECT * FROM t0 WHERE EXISTS (SELECT MIN(c0)  OVER (), CUME_DIST() OVER () FROM t0) BETWEEN 1 AND 1;"]}
{"index": 2055, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE VIEW v0(c0) AS SELECT TYPEOF(1) FROM t0;", "INSERT INTO t0(c0) VALUES (0), (1);", "SELECT * FROM t0 LEFT JOIN v0 ON t0.c0 WHERE NOT(v0.c0 = 'a'); -- unexpected: fetches no row"]}
{"index": 2056, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE VIEW v0(c0) AS SELECT LOWER(CAST('1e500' AS TEXT)) FROM t0;", "INSERT INTO t0(c0) VALUES (NULL);", "SELECT v0.c0 FROM v0, t0 WHERE t0.rowid NOT IN (0, 0, v0.c0); -- expected: '1e500', actual: Inf"]}
{"index": 2057, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0, c1);", "CREATE INDEX i0 ON t0(CAST(c0 AS NUMERIC));", "INSERT INTO t0(c0, c1) VALUES ('a', -1);", "SELECT * FROM t0 INDEXED BY i0 WHERE CAST(t0.c0 AS NUMERIC) > LOWER(t0.c1) GROUP BY t0.rowid; -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2058, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0, c1 NOT NULL DEFAULT 1, c2, PRIMARY KEY (c0, c1));", "INSERT INTO t0(c2) VALUES (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL);", "INSERT INTO t0(c2) VALUES ('a');", "ANALYZE t0;", "SELECT DISTINCT * FROM t0 WHERE NULL IS t0.c0; -- unexpected: |1|a is not part of the result set"]}
{"index": 2059, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INTEGER PRIMARY KEY, c1 TEXT);", "INSERT INTO t0(c0, c1) VALUES (1, 'a');", "SELECT * FROM t0 WHERE '-1' BETWEEN 0 AND t0.c0; -- expected: 1|a, actual: no row is fetched"]}
{"index": 2060, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT UNIQUE, c1);", "INSERT INTO t0(c0) VALUES (-1);", "SELECT * FROM t0 WHERE - x'ce' >= t0.c0; -- unexpected: row is not fetched"]}
{"index": 2061, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0);", "INSERT INTO t0(c0) VALUES ('a');", "SELECT * FROM t0 WHERE LIKELY(t0.rowid) <= '0'; -- unexpected: row is not fetched"]}
{"index": 2062, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT UNIQUE);", "INSERT INTO t0(c0) VALUES (1);", "SELECT * FROM t0 WHERE '1' IN (t0.c0); -- unexpected: fetches row"]}
{"index": 2063, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "INSERT INTO t0(c0) VALUES (NULL);", "CREATE INDEX i0 ON t0(1) WHERE c0 NOT NULL;", "SELECT * FROM t0 WHERE (t0.c0 IS FALSE) IS FALSE; -- unexpected: row is not fetched"]}
{"index": 2064, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c1);", "CREATE INDEX i0 ON t0(1) WHERE c1 NOTNULL;", "INSERT INTO t0(c1) VALUES (NULL);", "SELECT * FROM t0 WHERE t0.c1 IS FALSE BETWEEN FALSE AND TRUE; -- unexpected: row is not fetched"]}
{"index": 2065, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0);", "CREATE INDEX i0 ON t0(1) WHERE c0 NOT NULL;", "INSERT INTO t0(c0) VALUES (NULL);", "SELECT * FROM t0 WHERE '' BETWEEN t0.c0 AND 1 IN (FALSE); -- unexpected: row is not fetched"]}
{"index": 2066, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 REAL, c1 TEXT);", "CREATE INDEX i0 ON t0(+c0, c0);", "INSERT INTO t0(c0) VALUES(0);", "SELECT CAST(+ t0.c0 AS BLOB) LIKE 0 FROM t0; -- expected: 0, actual: 1"]}
{"index": 2067, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 REAL UNIQUE);", "INSERT INTO t0(c0) VALUES(2.07093491255203046E18);", "SELECT * FROM t0 WHERE c0 IN ('2070934912552030444'); -- unexpected: row is fetched"]}
{"index": 2068, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT, c1 REAL, c2, PRIMARY KEY(c2, c0, c1));", "CREATE INDEX i0 ON t0(c1 IN (c0));", "INSERT INTO t0(c0, c2) VALUES (0, NULL) ON CONFLICT(c2, c1, c0) DO NOTHING;", "UPDATE t0 SET c2 = x'';", "SELECT * FROM t0 WHERE t0.c2 IS NULL; -- unexpected: row is fetched"]}
{"index": 2069, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 COLLATE NOCASE, c1);", "CREATE INDEX i0 ON t0(0) WHERE c0 >= c1;", "REPLACE INTO t0 VALUES('a', 'B');", "SELECT * FROM t0 WHERE t0.c1 <= t0.c0; -- unexpected: row is not fetched"]}
{"index": 2070, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "INSERT INTO t0(c0) VALUES('');", "CREATE VIEW v2(c0, c1) AS SELECT 'B' COLLATE NOCASE, 'a' FROM t0 ORDER BY t0.c0;", "SELECT SUM(count) FROM (SELECT v2.c1 BETWEEN v2.c0 AND v2.c1 as count FROM v2); -- expected: 0, actual: 1"]}
{"index": 2071, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 COLLATE NOCASE);", "INSERT INTO t0(c0) VALUES ('B');", "CREATE VIEW v0(c0, c1) AS SELECT DISTINCT t0.c0, 'a' FROM t0;", "SELECT v0.c1 >= v0.c0 FROM v0; -- actual: 1, expected: 0"]}
{"index": 2072, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 UNIQUE);", "INSERT INTO t0 VALUES (-1);", "SELECT * FROM t0 WHERE t0.c0 GLOB '-*'; -- unexpected: row is not fetched"]}
{"index": 2073, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 PRIMARY KEY, c1);", "INSERT INTO t0(c0) VALUES (x'bb'), (0);", "SELECT COUNT(*) FROM t0 WHERE INSTR(x'aabb', t0.c0) ORDER BY t0.c0, t0.c1; -- 1", "SELECT * FROM t0 WHERE INSTR(x'aabb', t0.c0) ORDER BY t0.c0, t0.c1; -- no row is fetched"]}
{"index": 2074, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "INSERT INTO t0(c0) VALUES (0);", "CREATE VIEW v0(c0) AS SELECT t0.rowid FROM t0 ORDER BY 1;", "SELECT COUNT(*) FROM v0 WHERE ABS('1') = v0.c0; -- expected: 1, actual: 0"]}
{"index": 2075, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c1);", "CREATE TABLE t1(c0);", "CREATE VIEW v0 AS SELECT c1 FROM t1 LEFT JOIN t0;", "INSERT INTO t1 VALUES (1);", "SELECT * FROM v0 WHERE NOT(v0.c1 IS FALSE); -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2076, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE TABLE t1(c1);", "INSERT INTO t0(c0) VALUES(0);", "CREATE VIEW v0(c0) AS SELECT t1.c1 FROM t0 LEFT JOIN t1;", "SELECT * FROM v0 WHERE v0.c0 NOTNULL NOTNULL; -- expected: row is fetched, actual: no row is fetched"]}
{"index": 2077, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 COLLATE NOCASE, c1);", "INSERT INTO t0 VALUES('a', 'A');", "SELECT * FROM t0 WHERE (+ t0.c1, 1) >= (t0.c0, 1); -- expected: row is not fetched, actual: row is fetched"]}
{"index": 2078, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 COLLATE NOCASE, c1);", "INSERT INTO t0 VALUES('a', 'A');", "SELECT * FROM t0 WHERE (+ t0.c1, 1) >= (t0.c0, 1); -- expected: row is not fetched, actual: row is fetched"]}
{"index": 2079, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT PRIMARY KEY);", "INSERT INTO t0(c0) VALUES ('');", "SELECT * FROM t0 WHERE (t0.c0, TRUE) > (CAST('' AS REAL), FALSE); -- unexpected: row is not fetched"]}
{"index": 2080, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 UNIQUE);", "INSERT INTO t0(c0) VALUES('a');", "SELECT * FROM t0 WHERE (t0.c0, 0) < ('B' COLLATE NOCASE, 0); -- unexpected: row is not fetched"]}
{"index": 2081, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["PRAGMA temp.recursive_triggers = true;", "CREATE TABLE t0(c0, c1 UNIQUE);", "CREATE TRIGGER c BEFORE DELETE ON t0;", "BEGIN INSERT INTO t0(c1) VALUES(1);", "END;", "INSERT INTO t0(c1) VALUES(0);", "REPLACE INTO t0(c1) VALUES (0);", "SELECT t0.c1 BETWEEN 0 AND (CASE WHEN 1 THEN 1 ELSE t0.c0 END NOT NULL) FROM t0; -- expected: 1 and 1, actual: 1"]}
{"index": 2082, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE INDEX i0 ON t0(0) WHERE c0 GLOB c0;", "INSERT INTO t0 VALUES (0);", "CREATE UNIQUE INDEX i1 ON t0(0);", "CREATE UNIQUE INDEX i2 ON t0(0);", "REPLACE INTO t0 VALUES(0);", "SELECT COUNT(*) FROM t0 WHERE t0.c0 GLOB t0.c0; -- expected: 1, actual: 2"]}
{"index": 2083, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE TABLE t1(c0);", "INSERT INTO t1(c0) VALUES (0);", "CREATE INDEX i0 ON t0(0) WHERE NULL IN (c0);", "CREATE VIEW v0(c0) AS SELECT t0.c0 FROM t1 LEFT JOIN t0;", "SELECT COUNT(*) FROM v0 WHERE NULL IN (v0.c0); -- expected: 0, actual: 1"]}
{"index": 2084, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE TABLE t1(c0);", "CREATE VIEW v0(c0) AS SELECT t0.c0 FROM t1 LEFT JOIN t0;", "INSERT INTO t1(c0) VALUES (0);", "SELECT * FROM v0 WHERE (v0.c0, x'') != (NULL, 0); -- unexpected: row is not fetched"]}
{"index": 2085, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0 GENERATED ALWAYS AS (1), c1 UNIQUE, c2 UNIQUE);", "INSERT INTO t0(c1) VALUES (1);", "SELECT * FROM t0 WHERE 0 = t0.c2 OR t0.c1 BETWEEN t0.c2 AND 1; -- unexpected: row is fetched"]}
{"index": 2086, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE VIRTUAL TABLE vt0 USING fts5(c0);", "INSERT INTO t0(c0) VALUES (1), (0);", "INSERT INTO vt0(c0) VALUES (0), (0);", "CREATE VIEW v0 AS SELECT DISTINCT t0.c0 FROM vt0, t0 ORDER BY vt0.rowid;", "SELECT * FROM v0; -- unexpected: 4 rows are fetched"]}
{"index": 2087, "a_db": "postgresql", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 CHAR(2) COLLATE \"C\", c1 CHAR(2) COLLATE \"POSIX\");", "INSERT INTO t0 VALUES('', '');", "SELECT * FROM t0 WHERE t0.c1 NOT IN (t0.c0); -- unexpected: cache lookup failed for collation 0"]}
{"index": 2088, "a_db": "postgresql", "b_db": "cockroachdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 CHAR(2) COLLATE \"C\", c1 CHAR(2) COLLATE \"POSIX\");", "INSERT INTO t0 VALUES('', '');", "SELECT * FROM t0 WHERE t0.c1 NOT IN (t0.c0); -- unexpected: cache lookup failed for collation 0"]}
{"index": 2089, "a_db": "postgresql", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 boolean, c1 boolean, c2 boolean);", "INSERT INTO t0 VALUES(FALSE, FALSE, FALSE);", "CREATE STATISTICS s0 ON c0, c2 FROM t0;", "ANALYZE;", "SELECT * FROM t0 WHERE t0.c2 OR t0.c1 OR t0.c0; -- TRAP: FailedAssertion(\"clauses != NIL\", File: \"mcv.c\", Line: 1551)"]}
{"index": 2090, "a_db": "postgresql", "b_db": "cockroachdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 boolean, c1 boolean, c2 boolean);", "INSERT INTO t0 VALUES(FALSE, FALSE, FALSE);", "CREATE STATISTICS s0 ON c0, c2 FROM t0;", "ANALYZE;", "SELECT * FROM t0 WHERE t0.c2 OR t0.c1 OR t0.c0; -- TRAP: FailedAssertion(\"clauses != NIL\", File: \"mcv.c\", Line: 1551)"]}
{"index": 2091, "a_db": "postgresql", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "CREATE INDEX i0 ON t0(c0 bpchar_ops);", "SELECT * FROM t0 WHERE t0.c0 LIKE ''; -- ERROR:  no = operator for opfamily 426"]}
{"index": 2092, "a_db": "postgresql", "b_db": "cockroachdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 TEXT);", "CREATE INDEX i0 ON t0(c0 bpchar_ops);", "SELECT * FROM t0 WHERE t0.c0 LIKE ''; -- ERROR:  no = operator for opfamily 426"]}
{"index": 2093, "a_db": "postgresql", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 int);", "CREATE VIEW v0 AS SELECT * FROM t0;", "CREATE OR REPLACE VIEW v0 AS SELECT * FROM v0;", "SELECT * FROM information_schema.tables; -- server process (PID 2461) was terminated by signal 11: Segmentation fault"]}
{"index": 2094, "a_db": "postgresql", "b_db": "cockroachdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 int);", "CREATE VIEW v0 AS SELECT * FROM t0;", "CREATE OR REPLACE VIEW v0 AS SELECT * FROM v0;", "SELECT * FROM information_schema.tables; -- server process (PID 2461) was terminated by signal 11: Segmentation fault"]}
{"index": 2095, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE TABLE t1(c0);", "CREATE INDEX i0 ON t0(1) WHERE c0 ISNULL;", "INSERT INTO t0(c0) VALUES (1);", "INSERT INTO t1(c0) VALUES (1);", "SELECT * FROM t1 LEFT JOIN t0 WHERE t0.c0 ISNULL; -- unexpected: row is fetched"]}
{"index": 2096, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE VIRTUAL TABLE rt0 USING rtree(c0, c1, c2);", "INSERT INTO rt0(c2) VALUES(NULL);", "INSERT INTO t0 VALUES(0);", "SELECT * FROM rt0, t0 WHERE (t0.c0, 0) > (rt0.c2, 0); -- unexpected: row is fetched"]}
{"index": 2097, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 AS (1), c1);", "CREATE TABLE t1(c0);", "SELECT * FROM t0, t1 WHERE t0.c0 == 0; -- out of memory"]}
{"index": 2098, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE VIRTUAL TABLE vt0 USING rtree(c0, c1, c2);", "INSERT INTO t0(c0) VALUES(0);", "SELECT * FROM t0 LEFT JOIN vt0 ON c2 IN (0) WHERE c1 IN (NULL);"]}
{"index": 2099, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE TABLE t1(c0, c1 AS(1));", "INSERT INTO t0 VALUES(0);", "SELECT t1.c1 IS TRUE FROM t0 LEFT JOIN t1; -- expected: 0, actual: 1"]}
{"index": 2100, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE TABLE t1(c0, c1 UNIQUE);", "INSERT INTO t0(c0) VALUES(NULL);", "SELECT COUNT(*) FROM t0, t1 WHERE (SELECT AVG(0) FILTER(WHERE t1.c1)); -- segmentation fault"]}
{"index": 2101, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 REAL AS(1) UNIQUE, c1 INT);", "INSERT INTO t0 VALUES('');", "SELECT * FROM t0 WHERE (1 BETWEEN CAST(t0.c0 AS TEXT) AND t0.c0); -- unexpected: row is fetched"]}
{"index": 2102, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 UNIQUE);", "INSERT INTO t0 VALUES(0);", "SELECT * FROM t0 WHERE (0, t0.c0) IN(SELECT DENSE_RANK() OVER(), LAG(0) OVER() FROM t0); -- sqlite3.c:87244: sqlite3VdbeExec: Assertion `memIsValid(pRec)' failed."]}
{"index": 2103, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 UNIQUE);", "SELECT * FROM t0 WHERE(c0, 0) IN(SELECT FIRST_VALUE(0) OVER(), 0); -- Segmentation fault"]}
{"index": 2104, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE INDEX i0 ON t0((c0 NOTNULL) COLLATE BINARY);", "SELECT * FROM t0 WHERE(c0 NOTNULL) COLLATE BINARY BETWEEN 0 AND c0; -- sqlite3.c:98025: sqlite3ExprSkipCollateAndLikely: Assertion `pExpr->op==TK_COLLATE' failed."]}
{"index": 2105, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE VIRTUAL TABLE vt0 USING fts5(c0);", "CREATE TABLE t0(c0);", "CREATE VIEW v0(c0) AS SELECT 0 GROUP BY 1;", "SELECT * FROM v0, t0 LEFT JOIN vt0 ON vt0.c0 MATCH 1 WHERE v0.c0 == 0; -- sqlite3.c:143296: constructAutomaticIndex: Assertion `!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable!=pSrc->iCursor || pLoop->prereq!=0' failed."]}
{"index": 2106, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 UNIQUE);", "SELECT * FROM t0 WHERE (t0.c0, 1) IN(SELECT NTILE(1) OVER(), 0 FROM t0); -- sqlite3.c:90197: sqlite3VdbeExec: Assertion `pC!=0' failed."]}
{"index": 2107, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "CREATE TABLE t1(c0);", "SELECT * FROM t0 LEFT JOIN t1 WHERE (t1.c0 BETWEEN 0 AND 0) > ('' AND t0.c0); -- sqlite3.c:103271: impliesNotNullRow: Assertion `pWalker->eCode==0' failed."]}
{"index": 2108, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE VIRTUAL TABLE rt0 USING rtree(c0, c1, c2);", "CREATE TABLE t0(c0);", "INSERT INTO t0 VALUES (0), (1);", "INSERT INTO rt0(c0) VALUES (0), (1);", "CREATE VIEW v0 AS SELECT 0 LIMIT 0;", "SELECT * FROM t0 LEFT JOIN rt0 INNER JOIN v0; -- sqlite3.c:185720: rtreeRelease: Assertion `pRtree->nNodeRef==0 || pRtree->bCorrupt' failed."]}
{"index": 2109, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "SELECT (0, 0) IN(SELECT MIN(c0), NTILE(0) OVER()) FROM t0; -- sqlite3.c:103486: exprSrcCount: Assertion `0' failed."]}
{"index": 2110, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["PRAGMA recursive_triggers = true;", "CREATE TABLE t0(c0 UNIQUE ON CONFLICT REPLACE, c1, c2);", "CREATE INDEX i0 ON t0(c2);", "INSERT INTO t0(c0) VALUES (0);", "CREATE TRIGGER tr0 DELETE ON t0 BEGIN", "UPDATE t0 SET c2 = c0;", "END;", "INSERT INTO t0(c0, c2) VALUES(4, 0), (9, 0);", "UPDATE t0 SET c0 = 0;", "SELECT * FROM t0 WHERE x'' > t0.c2 GROUP BY c1; -- database disk image is malformed"]}
{"index": 2111, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0);", "INSERT INTO t0 VALUES('0');", "CREATE VIEW v0(c0) AS SELECT CAST(0 AS INT) FROM t0;", "SELECT * FROM t0, v0 WHERE 0 >= t0.c0 AND t0.c0 = v0.c0; -- unexpected: fetches row"]}
{"index": 2112, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["PRAGMA encoding = 'UTF16be';", "CREATE TABLE t0(c0, c1);", "INSERT INTO t0(c0) VALUES (x'00');", "CREATE INDEX i0 ON t0(c0 COLLATE BINARY);", "INSERT INTO t0(c0) VALUES (1);", "SELECT COUNT(*) FROM t0 WHERE SUBSTR(t0.c0, ','); -- expected: 1, actual: 2"]}
{"index": 2113, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 REAL, c1 REAL GENERATED ALWAYS AS (c0));", "INSERT INTO t0(c0) VALUES (1);", "SELECT * FROM t0 GROUP BY c0; -- expected: 1.0|1.0, actual: 1.0|1", "SELECT * FROM t0; -- 1.0|1.0"]}
{"index": 2114, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["PRAGMA encoding = 'UTF-16';", "CREATE TABLE t0(c0 TEXT);", "INSERT INTO t0(c0) VALUES ('윆'), (1);", "SELECT MAX(CASE 1 WHEN 1 THEN t0.c0 END) FROM t0; -- 윆", "SELECT MAX(t0.c0) FROM t0; -- 1"]}
{"index": 2115, "a_db": "mysql", "b_db": "mariadb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 DOUBLE);", "INSERT INTO t0 VALUES(0);", "INSERT INTO t1 VALUES('-0');", "SELECT * FROM t0, t1 WHERE t0.c0 = t1.c0; -- expected: {0, -0}, actual: {}"]}
{"index": 2116, "a_db": "mysql", "b_db": "tidb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 DOUBLE);", "INSERT INTO t0 VALUES(0);", "INSERT INTO t1 VALUES('-0');", "SELECT * FROM t0, t1 WHERE t0.c0 = t1.c0; -- expected: {0, -0}, actual: {}"]}
{"index": 2117, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0(c0) VALUES (0);", "SELECT * FROM t0 WHERE NOT(NULL OR TRUE); -- expected: {}, actual: {1}"]}
{"index": 2118, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0(c0) VALUES (NULL);", "SELECT * FROM t0 WHERE c0 = c0; -- expected: {}, actual: {NULL}"]}
{"index": 2119, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 NUMERIC UNIQUE);", "INSERT INTO t0(c0) VALUES (1163404482), (0), (488566);", "SELECT * FROM t0 WHERE 0.1 < c0; -- expected: {}, actual: {1163404482.0, 488566.0}"]}
{"index": 2120, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BOOL);", "CREATE TABLE t1(c0 BOOL);", "INSERT INTO t1(c0) VALUES (0);", "INSERT INTO t0(c0) VALUES (0);", "SELECT t0.c0 FROM t0, t1 WHERE t1.c0 < t0.c0; -- Error: Not implemented: Unimplemented type for sort"]}
{"index": 2121, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR, c1 DOUBLE);", "CREATE TABLE t1(c0 DOUBLE, PRIMARY KEY(c0));", "INSERT INTO t0(c0) VALUES (0), (0), (0), (0);", "INSERT INTO t0(c0) VALUES (NULL), (NULL);", "INSERT INTO t1(c0) VALUES (0), (1);", "", "SELECT t0.c0 FROM t0, t1; -- A fatal error has been detected by the Java Runtime Environment"]}
{"index": 2122, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT);", "SELECT * FROM t0 RIGHT JOIN t1 ON t0.c0!=t1.c0; -- Error: Unhandled type for empty NL join"]}
{"index": 2123, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c1 BOOLEAN);", "INSERT INTO t0(c0) VALUES (1);", "SELECT * FROM t0 RIGHT JOIN t1 on true; -- expected: {}, actual: {1|false}"]}
{"index": 2124, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT);", "SELECT * FROM t1 JOIN t0 ON t1.c0 < t1.c0 - t0.c0 WHERE t0.c0 <= t1.c0; -- Error: INTERNAL: Failed to bind column reference \"c0\" [5.0] (bindings: [6.0])"]}
{"index": 2125, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT);", "INSERT INTO t0(c0) VALUES (0);", "INSERT INTO t1(c0) VALUES (NULL);", "SELECT * FROM t1 LEFT JOIN t0 ON t0.c0=t1.c0; -- Segmentation fault"]}
{"index": 2126, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0(c0) VALUES (-10);", "SELECT * FROM t0 WHERE t0.c0 NOT SIMILAR TO 0; -- expected: {-10}, actual: {}"]}
{"index": 2127, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT);", "INSERT INTO t1(c0) VALUES (0);", "INSERT INTO t0(c0) VALUES (0);", "SELECT * FROM t0 LEFT JOIN t1 ON t0.c0 <= t1.c0; -- Not implemented: Unimplemented type for nested loop join!"]}
{"index": 2128, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE UNIQUE INDEX i0 ON t0(c0);", "INSERT INTO t0(c0) VALUES (1);", "INSERT INTO t0(c0) VALUES (1); -- Failed to commit: Constraint: PRIMARY KEY or UNIQUE constraint violated: duplicated key", "SELECT * FROM t0 WHERE t0.c0 = 1; -- expected: {1}, actual: {}"]}
{"index": 2129, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT8, c1 DOUBLE);", "INSERT INTO t1(c0) VALUES (0);", "INSERT INTO t1(c1, c0) VALUES (1, 1);", "INSERT INTO t0 VALUES (0);", "SELECT * FROM t1 JOIN t0 ON t1.c1 WHERE NOT (t1.c0<<-1); -- expected: {1|1|0}, actual: {}"]}
{"index": 2130, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BOOL UNIQUE);", "INSERT INTO t0(c0) VALUES (0);", "SELECT * FROM t0 WHERE t0.c0 = true; -- Error: Invalid type: Invalid Type [BOOL]: Invalid type for index"]}
{"index": 2131, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT);", "INSERT INTO t0(c0) VALUES (0);", "INSERT INTO t1(c0) VALUES (0);", "SELECT * FROM t1, t0 WHERE NOT ((t1.c0 AND t0.c0) < 0); -- expected: {0|0}, actual: {}"]}
{"index": 2132, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT);", "INSERT INTO t0(c0) VALUES (0);", "INSERT INTO t1(c0) VALUES (0), (0), (1), (-1);", "SELECT * FROM t0, t1 WHERE LN(t1.c0) < t0.c0; -- does not terminate"]}
{"index": 2133, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 FLOAT);", "INSERT INTO t0(c0) VALUES (1), (0);", "INSERT INTO t1(c0) VALUES (1);", "SELECT t1.c0 FROM t1 JOIN t0 ON t1.c0 IN (t0.c0) WHERE t1.c0<=t0.c0; -- expected: {1.0}, actual: {4.67454452791745e-310}"]}
{"index": 2134, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 REAL);", "CREATE TABLE t1(c0 INT2);", "CREATE TABLE t2(c0 INT);", "INSERT INTO t0 VALUES (-1);", "INSERT INTO t1 VALUES (0);", "INSERT INTO t2 VALUES (0), (0);", "SELECT * FROM t1, t2, t0 WHERE CONCAT(t1.c0) OR t0.c0; -- Segmentation fault"]}
{"index": 2135, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR);", "INSERT INTO t0(c0) VALUES (0.1);", "SELECT * FROM t0 WHERE REGEXP_MATCHES(t0.c0, '1'); -- expected: {0.1}, actual: {}"]}
{"index": 2136, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 DATE);", "INSERT INTO t0 VALUES (-10000000);", "SELECT c0 FROM t0; -- double free or corruption (out)"]}
{"index": 2137, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 REAL);", "INSERT INTO t0(c0) VALUES (10000000000);", "SELECT t0.c0 ::INT FROM t0; -- Error: Conversion: Invalid TypeId -1"]}
{"index": 2138, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR, c1 DOUBLE UNIQUE);", "INSERT INTO t0(c0) VALUES (NULL);", "UPDATE t0 SET c0=0;", "INSERT INTO t0(c0, c1) VALUES (0, 0);", "SELECT * FROM t0 WHERE 1 > c1; -- Segmentation fault"]}
{"index": 2139, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 NUMERIC);", "INSERT INTO t0(c0) VALUES (-515965088);", "INSERT INTO t0(c0) VALUES (1), (-5.15965088E8);", "CREATE INDEX i0 ON t0(c0);", "SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0); -- non-deterministic result"]}
{"index": 2140, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 VARCHAR);", "INSERT INTO t1 VALUES (0.9201898334673894), (0);", "INSERT INTO t0 VALUES (0);", "SELECT * FROM t0, t1 GROUP BY t0.c0, t1.c0 HAVING t1.c0!=MAX(t1.c0) UNION ALL SELECT * FROM t0, t1 GROUP BY t0.c0, t1.c0 HAVING NOT t1.c0>MAX(t1.c0); -- nondeterministic"]}
{"index": 2141, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE VIEW v0 AS SELECT 0, 1 FROM t0 ORDER BY t0.c0;", "SELECT t0.c0 FROM t0, v0; -- Conversion: Invalid TypeId <int>"]}
{"index": 2142, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BIGINT);", "INSERT INTO t0(c0) VALUES (-1);", "INSERT INTO t0(c0) VALUES (0);", "SELECT * FROM t0 WHERE t0.c0 AND (t0.c0<<64);-- expected: {}, actual: {-1}"]}
{"index": 2143, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR);", "INSERT INTO t0 VALUES ('aaaaaaaaaaaa');", "SELECT MAX(agg0) FROM (SELECT MAX(t0.c0) AS agg0 FROM t0) as s0; -- nondeterministic result or crash"]}
{"index": 2144, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c1 BIGINT);", "INSERT INTO t0(c1) VALUES (2);", "INSERT INTO t0(c1) VALUES (9223372036854775807);", "SELECT SUM(t0.c1) FROM t0; -- expected: {9223372036854776000}, actual: {-9223372036854775807}"]}
{"index": 2145, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0(c0) VALUES (0);", "CREATE VIEW v0(c0) AS SELECT 1 FROM t0;", "SELECT * FROM v0 ORDER BY 'a'; --  Assertion `types.size() > 0' failed (original test case crashed)"]}
{"index": 2146, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0 VALUES (0);", "SELECT * FROM t0 WHERE t0.c0 SIMILAR TO '.'; -- Assertion `strlen(dataptr) == length' failed"]}
{"index": 2147, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0 VALUES (NULL), (0), (1);", "SELECT * FROM t0 WHERE CASE WHEN c0 THEN 0 ELSE CASE '0.1' WHEN c0 THEN '' END END; -- Assertion `other.auxiliary->type == VectorBufferType::STRING_BUFFER' failed."]}
{"index": 2148, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE TABLE t1(c0 INT);", "SELECT * FROM t0 RIGHT JOIN t1 ON 0 WHERE t0.c0 OR t1.c0 BETWEEN t0.c0 AND 1; -- Assertion `filter->expressions.size() == 1' failed."]}
{"index": 2149, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0 (c0 INT);", "INSERT INTO t0 VALUES (0);", "SELECT SUM(-1) FROM t0; -- expected: {-1}, actual: {1.8446744073709552e+19}"]}
{"index": 2150, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "SELECT * FROM t0 GROUP BY -4.40304405E8 ORDER BY (CASE 1 WHEN 0 THEN 0 ELSE -440304405 END); -- Assertion `!entry.first->Equals(&expr)' failed."]}
{"index": 2151, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0 VALUES (-1);", "SELECT t0.c0 FROM t0 WHERE NOT (0 BETWEEN 0 AND t0.c0::BOOL); -- expected: {}, actual: {-1}"]}
{"index": 2152, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR);", "SELECT * FROM t0 WHERE PREFIX(t0.c0, ''); -- Error: std::bad_alloc"]}
{"index": 2153, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR, c1 VARCHAR);", "INSERT INTO t0(c0) VALUES(0), ('');", "UPDATE t0 SET c1 = 1;", "SELECT t0.c1 FROM t0 WHERE '' = t0.c0; -- expected: {1}, actual: {''}"]}
{"index": 2154, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BOOLEAN);", "INSERT INTO t0 VALUES (NULL), (false);", "SELECT DISTINCT t0.c0 FROM t0; -- expected: {NULL, false}, actual: {NULL, NULL}"]}
{"index": 2155, "a_db": "sqlite", "b_db": "duckdb", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "CREATE VIEW v0(c0) AS SELECT CAST(t0.c0 AS INTEGER) FROM t0;", "INSERT INTO t0(c0) VALUES (0);", "SELECT * FROM t0 LEFT JOIN v0 ON v0.c0 >= '0' WHERE TRUE UNION SELECT 0,0 WHERE 0; -- expected: {0|0}, actual:{0|NULL}"]}
{"index": 2156, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR);", "INSERT INTO t0(c0) VALUES (0);", "UPDATE t0 SET c0=0;", "UPDATE t0 SET c0=true;", "SELECT * FROM t0 WHERE t0.c0 = true; -- expected: {true}, actual: {}"]}
{"index": 2157, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INTEGER);", "INSERT INTO t0(c0) VALUES (-2);", "SELECT t0.c0 FROM t0 WHERE -1 BETWEEN t0.c0::VARCHAR AND 1; -- expected: {-2}, actual: {}"]}
{"index": 2158, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR);", "INSERT INTO t0(c0) VALUES (''), (0);", "SELECT * FROM t0 WHERE t0.c0 = ''; -- expected: {''}, actual: {}"]}
{"index": 2159, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0 VALUES (1), (0), (1);", "SELECT t0.rowid FROM t0 WHERE t0.rowid ORDER BY CASE ((t0.c0) ::BOOL) WHEN 1 THEN t0.rowid END; -- expected: {0, 2}, actual: {140671047175328, 2}"]}
{"index": 2160, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR);", "INSERT INTO t0(c0) VALUES (DATE '2000-01-02');", "SELECT * FROM t0 WHERE DATE '2000-01-01' < t0.c0; -- expected: {2000-01-02}, actual: {}"]}
{"index": 2161, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR);", "INSERT INTO t0 VALUES (0);", "SELECT * FROM t0 WHERE c0 LIKE '' AND c0 < true; -- Assertion `tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN || tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO' failed."]}
{"index": 2162, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 DOUBLE);", "INSERT INTO t0(c0) VALUES(1E200), (0);", "SELECT STDDEV_POP(c0) FROM t0; -- unexpected: does not fetch a row"]}
{"index": 2163, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR COLLATE NOCASE);", "INSERT INTO t0(c0) VALUES ('a'), ('A');", "SELECT t0.c0 FROM t0 GROUP BY t0.c0; -- expected: {'a'} or {'A'}, actual: {'a', 'A'}"]}
{"index": 2164, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT);", "INSERT INTO t0 VALUES (-1);", "SELECT MIN(CAST(c0 AS BIGINT) << 63) FROM t0; -- expected: {-9223372036854775808}, actual: {NULL}"]}
{"index": 2165, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 INT UNIQUE, c1 DATE);", "ALTER TABLE t0 ALTER c1 TYPE INT;", "INSERT INTO t0(c0) VALUES(-1);", "SELECT * FROM t0 WHERE c0 < 0; -- Segmentation fault"]}
{"index": 2166, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 BOOL);", "INSERT INTO t0(c0) VALUES (NULL);", "SELECT * FROM t0 WHERE LEFT(t0.c0, -1); -- Segmentation fault"]}
{"index": 2167, "a_db": "duckdb", "b_db": "postgres", "molt": "norec", "sqls": ["CREATE TABLE t0(c0 VARCHAR);", "CREATE TABLE t1(c0 VARCHAR);", "INSERT INTO t0 VALUES('');", "INSERT INTO t1 VALUES(0);", "CREATE VIEW v0 AS SELECT 0 FROM t0, t1 WHERE t0.c0 = t1.c0;", "SELECT * FROM v0 RIGHT JOIN t1 ON 1; -- Assertion `!finalized' failed"]}
